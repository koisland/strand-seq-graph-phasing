###################################
############ Libraries ############
###################################

import pathlib

################################
############ Config ############
################################

segment_length_threshold = config["segmentLengthThreshold"]

deploy_offline = config["deploy_offline"]

scripts_dir = config["scripts_dir"]

reference = config.get('reference', None)

################################
########## Variables ###########
################################

bwa_index_suffices = ["amb", "ann", "bwt", "pac", "sa"]

###################################
############ Rules ################
###################################

include: 'rules/sample_table.smk'

if reference:
    include: 'rules/evaluate.smk'


#####################################
############ Offline/Online #########
#####################################

if deploy_offline:
    conda_r_env = None
    singularity_r_env = config["singularity_Renv"]
    if not pathlib.Path(singularity_r_env).is_file():
        raise FileNotFoundError('R Singularity environment not found.')
else:
    conda_r_env = "envs/env_Renv2.yaml"
    singularity_r_env = None

###############################
############ All ##############
###############################

rule all:
    input:
        phased_unitigs = expand("phasing/{sample}_phased_unitigs.tsv", sample=SAMPLES)

################################################
############ Unmerged SS Processing ############
################################################

# Unmerged reads are aligned in bwa mem paired end mode, and alignments are
# used for the initial clustering step which assigns
# unitig chromosome and orientation, and calls library strand state
def sample2ss(wildcards):
    out = MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_dir'] + "/{lib}_{pair}" + MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_suffix']
    return out

rule unzip_ss:
    input: sample2ss
    output: temp("ss/unmerged/{sample}/{lib}_{pair}.fasta")
    conda:'envs/env_cl.yaml'
    log: "log/unzip_ss_{sample}_{lib}_{pair}.log"
    shell:
        '''
        (time bioawk -c fastx '{{print \">\"$name; print $seq}}' <(cat {input}) > {output}) > {log} 2>&1
        '''

rule add_ss_libname_unmerged:
    input: "ss/unmerged/{sample}/{lib}_{pair}.fasta"
    output: temp("ss/unmerged/{sample}/{lib}_{pair}.renamed.fasta")
    conda:'envs/env_cl.yaml'
    log: "log/add_ss_libname_{sample}_{lib}_{pair}.log"
    shell:
        '''
        (bioawk -c fastx -v libname={wildcards.lib} '{{print \">\"$name"_"libname; print $seq}}' <(cat {input}) > {output}) > {log} 2>&1
        '''

rule homopolymer_compress_unmerged_ss:
    input: "ss/unmerged/{sample}/{lib}_{pair}.renamed.fasta"
    output: "ss/unmerged/{sample}/{lib}_{pair}.homopolymer-compressed.fasta"
    conda:'envs/env_pyenv.yaml'
    log: "log/compress_unmerged_ss_{sample}_{lib}_{pair}.log"
    shell:
        '''
        (python3 scripts/python/homopolymer_compress_fasta.py \\
        --input {input} \\
        --output {output}) > {log} 2>&1
        '''


##############################################
############ Merged SS Processing ############
##############################################
# Merged SS reads are used with bwa fastmap, for longer exact matches.
# How useful merging actually is for that step is untested, but it feels like
# the right thing to do as fastmap does not have a paired alignment mode

# TODO check the name of the merged reads, does it simply take the name of the first read in the pair?


rule pear_merge_mates:
    input:
        fq1=lambda wildcards: MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_dir']+"/{lib}_1"+MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_suffix'],
        fq2=lambda wildcards: MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_dir']+"/{lib}_2"+MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_suffix'],
    output:
        "ss/merged/{sample}/{lib}.assembled.fastq",
        "ss/merged/{sample}/{lib}.discarded.fastq",
        "ss/merged/{sample}/{lib}.unassembled.forward.fastq",
        "ss/merged/{sample}/{lib}.unassembled.reverse.fastq"
    conda:'envs/env_cl.yaml'
    resources:
        mem_mb = lambda wildcards, attempt: 4096 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log: "log/pear_merge_mates_{sample}_{lib}.log"
    shell: "(pear -f {input.fq1} -r {input.fq2} -t 101 -o {wildcards.sample}/ss/merged/{wildcards.lib}) > {log} 2>&1"

rule concat_assembled_with_first_pair_of_unassembled:
    input:
        "ss/merged/{sample}/{lib}.assembled.fastq",
        "ss/merged/{sample}/{lib}.unassembled.forward.fastq"
    output: temp("ss/merged/{sample}/{lib}.combined.fasta")
    conda:'envs/env_cl.yaml'
    log: "log/concat_merged_with_first_unmerged_{sample}_{lib}.log"
    shell: "(time bioawk -c fastx '{{print \">\"$name; print $seq}}' <(cat {input}) > {output}) > {log} 2>&1"

rule add_ss_libname_merged:
    input: "ss/merged/{sample}/{lib}.combined.fasta"
    output: temp("ss/merged/{sample}/{lib}.combined.renamed.fasta")
    conda:'envs/env_cl.yaml'
    # log: "log/add_ss_libname_{sample}_{lib}.log"
    shell:
        '''
        bioawk -c fastx -v libname={wildcards.lib} '{{print \">\"$name"_"libname; print $seq}}' <(cat {input}) > {output}
        '''

rule homopolymer_compress_merged_ss:
    input: "ss/merged/{sample}/{lib}.combined.renamed.fasta" # concat_assembled_with_first_pair_of_unassembled
    output: "ss/merged/{sample}/{lib}.combined.homopolymer-compressed.fasta"
    conda:'envs/env_pyenv.yaml'
    # log: "log/compress_ss_{sample}_{lib}.log"
    shell:
        '''
        python3 scripts/python/homopolymer_compress_fasta.py \\
        --input {input} \\
        --output {output}
        '''

#######################################
############ Index Unitigs ############
#######################################
rule gfa_to_fasta:
    input: lambda wildcards: MAP_SAMPLE_TO_INPUT[wildcards.sample]['gfa']
    output: "fasta/{sample}/{sample}_assembly.fa"
    threads: 2
    log: "log/gfa_to_fasta_{sample}.log"
    shell:
        '''
        (time grep S {input} | awk '{{print \">\"$2\"\\n\"$3}}' > {output}) > {log} 2<&1
        '''

rule bwa_index_unitigs:
    input: "fasta/{sample}/{sample}_assembly.fa" # gfa_to_fasta
    output: expand("fasta/{{sample}}/{{sample}}_assembly.fa.{bwa_index_suffix}", bwa_index_suffix=bwa_index_suffices)
    conda:'envs/env_cl.yaml'
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 8 * attempt,
        walltime = lambda wildcards, attempt: f'{8 + attempt*attempt:02}:59:00'
    log: "log/bwa_index_unitigs_{sample}.log"
    shell: "(time bwa index {input}) > {log} 2>&1"
#####################################################################
############ Align Unmerged SS Reads to Assembly Unitigs ############
#####################################################################

rule bwa_align_unmerged_compressed_ss_to_unitigs:
    input:
        unitigs="fasta/{sample}/{sample}_assembly.fa", # gfa_to_fasta
        unitigs_index=expand("fasta/{{sample}}/{{sample}}_assembly.fa.{bwa_index_suffix}", bwa_index_suffix=bwa_index_suffices), # bwa_index_unitigs
        mate1="ss/unmerged/{sample}/{lib}_1.homopolymer-compressed.fasta",
        mate2="ss/unmerged/{sample}/{lib}_2.homopolymer-compressed.fasta"
    output: temp("temp_unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{sample}/{lib}.bam")
    threads: 6
    conda:'envs/env_cl.yaml'
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 16 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log:
        bwa="log/bwa_align_unmerged_compressed_ss_to_unitigs_bwa_{sample}_{lib}.log",
        samtools="log/bwa_align_unmerged_compressed_ss_to_unitigs_samtools_{sample}_{lib}.log"
    shell:
        '''
        bwa mem -t {threads} -R "@RG\\tID:{wildcards.lib}" -v 2 {input.unitigs} {input.mate1} {input.mate2} 2> {log.bwa} | samtools view -b -F 2304 /dev/stdin > {output} 2> {log.samtools}
        '''

rule bwa_sort_unmerged_compressed_ss_alignments:
    input:  "temp_unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{sample}/{lib}.bam" # bwa_align
    output: temp("unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{sample}/{lib}.bam")
    conda:'envs/env_cl.yaml'
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 8 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log: "log/bwa_sort_unmerged_{sample}_{lib}.log"
    shell:
        '''
        (time samtools sort -o {output} {input}) > {log} 2>&1
        '''

rule unmerged_mark_duplicates:
    input:  "unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{sample}/{lib}.bam" # bwa_sort
    output: "unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{sample}/{lib}.mdup.bam"
    conda:'envs/env_cl.yaml'
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 8 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log: "log/unmerged_mark_duplicates_{sample}_{lib}.log"
    shell:
        '''
        (time sambamba markdup {input} {output}) > {log} 2>&1
        '''

rule unmerged_bwa_index:
    input:  "unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{sample}/{lib}.mdup.bam" # mark_duplicates
    output: "unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{sample}/{lib}.mdup.bam.bai"
    conda:'envs/env_cl.yaml'
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 8 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log: "log/unmerged_bwa_index_{sample}_{lib}.log"
    shell:
        '''
        (time samtools index {input}) > {log} 2>&1
        '''


###############################################################
############ Clustering, Orientation, Strand State ############
###############################################################

# For Mir, there is a recent bug where the rscript cannot access the contents of any folder
# except the working directory. However, shell commands appear to work just fine.

rule copy_assembly_to_wd:
    input:
        lambda wildcards: MAP_SAMPLE_TO_INPUT[wildcards.sample]['gfa']
    output:
        temp("{sample}/assembly.gfa")
    shell: 'cp {input} {output}'

rule clust_orient_strand_state:
    input:
        bam=lambda wildcards: expand("unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{{sample}}/{lib}.mdup.bam", lib=MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_libs']), # mark_duplicates
        bai=lambda wildcards: expand("unmerged_bwa_ss_unitigs/unmerged_compressed_ss/{{sample}}/{lib}.mdup.bam.bai", lib=MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_libs']), # bwa_index
        gfa="{sample}/assembly.gfa"
    output:
        ML_clust="clustering_orientation_strandstate/{sample}/unitig_clusters.tsv", # ~ MLclust.data ~ unitig_clusters.tsv
        clust_pairs="clustering_orientation_strandstate/{sample}/clust_partners.tsv", # clust_partners.txt ~ clust_partners.tsv
        wc_cells_clusters="clustering_orientation_strandstate/{sample}/wc_libraries.tsv", # wc_cells_clusters.data ~ wc_libraries.tsv
        unclustered='clustering_orientation_strandstate/{sample}/excluded_unitigs.tsv'
    params:
        prefix = lambda wildcards: expand("clustering_orientation_strandstate/{sample}/", sample=wildcards.sample),
        segment_length_threshold=segment_length_threshold
    singularity: singularity_r_env
    conda: conda_r_env
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 32 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    threads: 8 # 24
    log: "log/cos_{sample}.log"
    shell:
        '''
        Rscript --vanilla scripts/R/clustering_orient_strandstate.snakemake.R \\
        --bam {input.bam} \\
        --gfa {input.gfa} \\
        --output-prefix {params.prefix} \\
        --threads {threads} \\
        --segment-length-threshold {params.segment_length_threshold} \\
        --log {log}
        '''


##########################################
############ Bubble Detection ############
##########################################

rule simplify_assembly:
    input:
        assembly=lambda wildcards: MAP_SAMPLE_TO_INPUT[wildcards.sample]['gfa'],
        clusters="clustering_orientation_strandstate/{sample}/unitig_clusters.tsv"
    output: "graph_components/{sample}/simplified_assembly.gfa"
    conda:'envs/env_gfa.yaml'
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 16 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log: "log/simplify_assembly_{sample}.log"
    shell:
        '''
        (python3 scripts/python/simplify_gfa.py \\
        --input {input.assembly} \\
        --output {output} \\
        --clusters {input.clusters}) > {log} 2>&1
        '''

rule detect_bubbles:
    input: "graph_components/{sample}/simplified_assembly.gfa"
    output: "graph_components/{sample}/simplified_assembly.gfa.json"
    conda:'envs/env_bubblegun.yaml'
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 8 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log: "log/detect_bubbles_assembly_{sample}.log"
    shell: "(time BubbleGun -g {input} bchains --only_simple --bubble_json {output})> {log} 2>&1"



#############################################################
############ FastMapping merged Strand-seq reads ############
#############################################################

rule fastmap_ss_reads_to_unitigs:
	input:
		unitigs="fasta/{sample}/{sample}_assembly.fa",# gfa_to_fasta
		unitigs_index=expand("fasta/{{sample}}/{{sample}}_assembly.fa.{bwa_index_suffix}",bwa_index_suffix=bwa_index_suffices),# bwa_index_unitigs
		SSreads="ss/merged/{sample}/{lib}.combined.homopolymer-compressed.fasta",
	output: "exact_match/{sample}/{lib}_maximal_unique_exact_match.tsv" # fastmap doesn't output bam
	threads: 2
	conda: 'envs/env_cl.yaml'
	resources:
		mem_mb=lambda wildcards, attempt: 1024 * 8 * attempt,
		walltime=lambda wildcards, attempt: f'{attempt * attempt:02}:59:00'
	log: "log/map_SS_reads_to_unitigs_{sample}_{lib}.log"
	shell: "(bwa fastmap -w 1 -l 75 {input.unitigs} {input.SSreads} > {output}) > {log} 2>&1"


#############################################################
############ Identifying Phase-Informative Reads ############
#############################################################


# This script extracts extracts reads with unique alignments, and labels if the alignment is to a bubble contig.
# TODO This script can likely be hugely simplified by taking the blocks that only indicate a match of length 1
# EG under an SQ or //SQ row, a single "EM XX YY 1"
rule output_valid_maps:
    input:
        map="exact_match/{sample}/{lib}_maximal_unique_exact_match.tsv", # map_ss_reads_to_unitigs
        bubbles="graph_components/{sample}/simplified_assembly.gfa.json", # detect_bubbles_overlap_graph
    output: "valid_exact_match/{sample}/{lib}_valid_maximal_unique_exact_match.tsv" # valid_{component}_maximal_unique_exact_match.data"
    conda:'envs/env_pyenv.yaml'
    # resources:
    #     mem_mb = lambda wildcards, attempt: 1024 * 8 * attempt,
    #     walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log: "log/output_valid_maps_{sample}_{lib}.log"
    shell:
        '''
        (python3 scripts/python/output_valid_maps.snakemake.py \\
                --bubbles {input.bubbles} \\
                --map {input.map} \\
                --output {output}) > {log} 2>&1
        '''
#################################
############ Phasing ############
#################################

def sample2maps(wildcards):
    out = expand("valid_exact_match/{{sample}}/{lib}_valid_maximal_unique_exact_match.tsv",
        lib=MAP_SAMPLE_TO_INPUT[wildcards.sample]['strandseq_libs'])
    return out

rule phase_unitigs:
    input:
        unitigs_clust="clustering_orientation_strandstate/{sample}/unitig_clusters.tsv", # COS
        clust_pairs="clustering_orientation_strandstate/{sample}/clust_partners.tsv", # COS
        map=sample2maps, # output_valid_maps
        bubbles="graph_components/{sample}/simplified_assembly.gfa.json", # detect_bubbles_overlap_graph
        wc_cell_clust="clustering_orientation_strandstate/{sample}/wc_libraries.tsv", # COS
    output:"phasing/{sample}_phased_unitigs.tsv",
    singularity: singularity_r_env
    conda: conda_r_env
    resources:
        mem_mb = lambda wildcards, attempt: 1024 * 32 * attempt,
        walltime = lambda wildcards, attempt: f'{attempt*attempt:02}:59:00'
    log: "log/phase_unitigs_{sample}.log"
    shell:
        '''
        Rscript --vanilla scripts/R/phase_bubbles.snakemake.R \\
        --clust-pairs {input.clust_pairs} \\
        --wc-cell-clust {input.wc_cell_clust} \\
        --unitig-clust {input.unitigs_clust} \\
        --map {input.map} \\
        --bubbles {input.bubbles} \\
        --sample {wildcards.sample} \\
        --output {output} \\
        --log {log}
           '''

